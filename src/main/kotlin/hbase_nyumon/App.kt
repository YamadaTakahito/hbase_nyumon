/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package hbase_nyumon

import org.apache.hadoop.hbase.HBaseConfiguration
import org.apache.hadoop.hbase.client.Append
import org.apache.hadoop.hbase.client.Delete
import org.apache.hadoop.hbase.client.Get
import org.apache.hadoop.hbase.client.HTable
import org.apache.hadoop.hbase.client.Increment
import org.apache.hadoop.hbase.client.Put
import org.apache.hadoop.hbase.client.Row
import org.apache.hadoop.hbase.client.RowMutations
import org.apache.hadoop.hbase.client.Scan
import org.apache.hadoop.hbase.util.Bytes

fun main(args: Array<String>) {
    val conf = HBaseConfiguration.create()
    val table = HTable(conf, "ns:tbl")

//    put(table)
//    get(table)
//    exist(table)
//    delete(table)
//    exist(table)
//    mutate(table)
//    setReversed(table)
//    increment(table)
//    append(table)
//    checkAndPut(table)
//    checkAndDelete(table)
    batch(table)


    table.close()
}

fun put(table: HTable) {
    val put = Put(Bytes.toBytes("row1"))
    put.add(Bytes.toBytes("fam"), Bytes.toBytes("col1"), Bytes.toBytes("value1"))
    put.add(Bytes.toBytes("fam"), Bytes.toBytes("col2"), 100L, Bytes.toBytes("value1"))
    table.put(put)
}

fun get(table: HTable) {
    val get = Get(Bytes.toBytes("row1"))
    get.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
    get.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col2"))

    val result = table.get(get)
    val col1 = result.getValue(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
    val col2 = result.getValue(Bytes.toBytes("fam"), Bytes.toBytes("col2"))

    println(col1)
    println(col2)
}

fun exist(table: HTable) {
    val get = Get(Bytes.toBytes("row1"))
    get.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
    val result = table.exists(get)
    println(result)
}

fun delete(table: HTable) {
    val delete = Delete(Bytes.toBytes("row1"))
    delete.deleteColumn(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
    delete.deleteColumn(Bytes.toBytes("fam"), Bytes.toBytes("col2"), 100L)

    table.delete(delete)
}

fun mutate(table: HTable) {
    val row = Bytes.toBytes("row1")

    val put = Put(row)
    put.add(Bytes.toBytes("fam"), Bytes.toBytes("col1"), Bytes.toBytes("value"))

    val delete = Delete(row)
    delete.deleteColumns(Bytes.toBytes("fam"), Bytes.toBytes("col2"))

    val rowMutations = RowMutations(row)
    rowMutations.add(put)
    rowMutations.add(delete)

    table.mutateRow(rowMutations)
}

fun scan(table: HTable) {
    val scan = Scan()
    scan.startRow = Bytes.toBytes("row1")
    scan.stopRow = Bytes.toBytes("row3")
    scan.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
    scan.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col2"))

    val scanner = table.getScanner(scan)
    for (result in scanner) {
        val col1 = result.getValue(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
        val col2 = result.getValue(Bytes.toBytes("fam"), Bytes.toBytes("col2"))
        println(col1)
        println(col2)
    }
}

fun setReversed(table: HTable) {
    val scan = Scan()
    scan.startRow = Bytes.toBytes("row4")
    scan.stopRow = Bytes.toBytes("row1")
    scan.isReversed = true

    val scanner = table.getScanner(scan)
    for (result in scanner) {
        println(result)
        val col1 = result.getValue(Bytes.toBytes("fam"), Bytes.toBytes("col1"))
        println(col1)
    }

}

fun increment(table: HTable) {
    val increment = Increment(Bytes.toBytes("row1"))
    increment.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col1"), 1)
    increment.addColumn(Bytes.toBytes("fam"), Bytes.toBytes("col2"), 2)

    val result = table.increment(increment)
    println(result)
}

fun append(table: HTable) {
    val append = Append(Bytes.toBytes("row1"))
    append.add(Bytes.toBytes("fam"), Bytes.toBytes("col1"), Bytes.toBytes("appendValue1"))
    append.add(Bytes.toBytes("fam"), Bytes.toBytes("col2"), Bytes.toBytes("appendValue2"))
    val result = table.append(append)
    println("result $result")
}

fun checkAndPut(table: HTable) {
    val row = Bytes.toBytes("row1")
    val fam = Bytes.toBytes("fam")
    val col = Bytes.toBytes("col1")

    val put = Put(row)
    put.add(fam, col, Bytes.toBytes("value2"))

    val result = table.checkAndPut(row, fam, col, Bytes.toBytes("value1"), put)
    println("result: $result")
}

fun checkAndDelete(table: HTable) {
    val row = Bytes.toBytes("row1")
    val fam = Bytes.toBytes("fam")
    val col = Bytes.toBytes("col1")

    val delete = Delete(row)
    val result = table.checkAndDelete(row, fam, col, Bytes.toBytes("value1"), delete)
    println("result: $result")
}

fun batch(table: HTable) {
    val actions: MutableList<Row> = mutableListOf()

    val put = Put(Bytes.toBytes("row1"))
    put.add(Bytes.toBytes("fam"), Bytes.toBytes("col"), Bytes.toBytes("value1"))
    actions.add(put)


    val results = actions.size
    table.batch(actions)

//    va
//    val actions = mutableListOf<Row>()

}